Project 4: Movie Recommendation
Fall 2022
Team members and contributions
Name: Gang Yao(gangyao2) Online MCS, Shi Qiu(qiushi2) STAT542, Yifei Kang (yifeik3)
STAT542
Gang Yao: Work on the System I/II and App code
Yifei Kang: Work on the App code
Qiu Shi: Work on part of System I code
Gang Yao and Yifei Kang reviewed the model results, walked through the results together and finalized the report

```{r}
# popularity-based recommendation
library(tidyverse)
library(dplyr)
library(ggplot2)
library(recommenderlab)
library(DT)
library(data.table)
library(reshape2)
```

System I: Recommendation based on genres

```{r}
myurl = "https://liangfgithub.github.io/MovieData/"

ratings = read.csv(paste0(myurl, 'ratings.dat?raw=true'), 
                   sep = ':',
                   colClasses = c('integer', 'NULL'), 
                   header = FALSE)

colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')

movies = readLines(paste0(myurl, 'movies.dat?raw=true'))
movies = strsplit(movies, split = "::", fixed = TRUE, useBytes = TRUE)
movies = matrix(unlist(movies), ncol = 3, byrow = TRUE)
movies = data.frame(movies, stringsAsFactors = FALSE)
colnames(movies) = c('MovieID', 'Title', 'Genres')
movies$MovieID = as.integer(movies$MovieID)

# convert accented characters
movies$Title[73]
```

```{r}
movies$Title = iconv(movies$Title, "latin1", "UTF-8")
movies$Title[73]
```
```{r}
# extract year
movies$Year = as.numeric(unlist(
  lapply(movies$Title, function(x) substr(x, nchar(x)-4, nchar(x)-1))))


# User data
users = read.csv(paste0(myurl, 'users.dat?raw=true'),
                 sep = ':', header = FALSE)
users = users[, -c(2,4,6,8)] # skip columns
colnames(users) = c('UserID', 'Gender', 'Age', 'Occupation', 'Zip-code')


```
```{r}
dim(users)
length(unique(ratings$UserID))
dim(movies)
```
Ratings per Movie
There are 31 movies that have received more than 2000 ratings. The most popular movie is “American Beauty (1999)”, followed by the “Star Wars” series. Throughout, popular means receiving many ratings; a popular movie may not be a highly-rated movie.
```{r}
tmp = ratings %>% 
  group_by(MovieID) %>% 
  summarize(ratings_per_movie = n(), ave_ratings = mean(Rating)) %>%
  inner_join(movies, by = 'MovieID')
summary(tmp$ratings_per_movie)
```
```{r}
tmp %>% 
  filter(ratings_per_movie > 2000) %>%
  arrange(desc = ratings_per_movie) %>%
  select(c("Title", "ratings_per_movie")) %>%
  print(n = 31)
```
The top ten highly-rated (based on their average ratings) among all movies that have received at least 1000 ratings.

```{r}
small_image_url = "https://liangfgithub.github.io/MovieImages/"
ratings %>% 
  group_by(MovieID) %>% 
  summarize(ratings_per_movie = n(), 
            ave_ratings = round(mean(Rating), dig=3)) %>%
  inner_join(movies, by = 'MovieID') %>%
  filter(ratings_per_movie > 1000) %>%
  top_n(10, ave_ratings) %>%
  mutate(Image = paste0('<img src="', 
                        small_image_url, 
                        MovieID, 
                        '.jpg?raw=true"></img>')) %>%
  select('Image', 'Title', 'ave_ratings') %>%
  arrange(desc(-ave_ratings)) %>%
  datatable(class = "nowrap hover row-border", 
            escape = FALSE, 
            options = list(dom = 't',
                          scrollX = TRUE, autoWidth = TRUE))
```
Dist of Genres
First cretae a bibary indicator for the 18 genres for each movie

```{r}
genres = as.data.frame(movies$Genres, stringsAsFactors=FALSE)
tmp = as.data.frame(tstrsplit(genres[,1], '[|]',
                              type.convert=TRUE),
                    stringsAsFactors=FALSE)
genre_list = c("Action", "Adventure", "Animation", 
               "Children's", "Comedy", "Crime",
               "Documentary", "Drama", "Fantasy",
               "Film-Noir", "Horror", "Musical", 
               "Mystery", "Romance", "Sci-Fi", 
               "Thriller", "War", "Western")
m = length(genre_list)
genre_df = matrix(0, nrow(movies), length(genre_list))
for(i in 1:nrow(tmp)){
  genre_df[i,genre_list %in% tmp[i,]]=1
}
colnames(genre_df) = genre_list
remove("tmp", "genres")
```

Then we can output historograms of the 18 genres baesd on movies or based on ratings.

```{r}
data.frame(Genres = genre_list, 
                 Freq = as.vector(colMeans(genre_df))) %>% 
  ggplot(aes(reorder(Genres, Freq), Freq, fill = Freq)) + 
  geom_bar(stat = "identity") + 
    geom_text(aes(label = round(Freq, dig=2)), 
            position = position_stack(vjust = 0.5), 
            color="white", size=3) + 
  coord_flip() + 
  scale_colour_brewer(palette="Set1") + 
  labs(y = 'Frequency', x = 'Genre')
```
Top-five most popular movies in Drama genre


```{r}
mydata <- ratings %>% 
  left_join(data.frame(MovieID = movies$MovieID, genre_df), 
            by = "MovieID")%>%
  select(c('UserID', 'MovieID', 'Rating', 'Timestamp','Drama'))

i = paste0('u', mydata$UserID)
j = paste0('m', mydata$MovieID)
x = mydata$Rating
tmp_mat = data.frame(i, j, x, stringsAsFactors = T)
Rmat_tmp = sparseMatrix(as.integer(tmp_mat$i), as.integer(tmp_mat$j), x = tmp_mat$x)
rownames(Rmat_tmp) = levels(tmp_mat$i)
colnames(Rmat_tmp) = levels(tmp_mat$j)
Rmat_tmp = new('realRatingMatrix', data = Rmat_tmp)

train_tmp = Rmat_tmp[1:500,]

mydata
```

```{r}
rec_popular = Recommender(train_tmp, method = 'POPULAR')
recom = predict(rec_popular, train_tmp, type = 'ratings')
```
```{r}
recom2 = predict(rec_popular, train_tmp, type = 'topN') # recommend top n=10 items for each user
recom2
```


```{r}
user1 = recom2@items[[1]] # recommendation for the first user
movies_user1 = recom2@itemLabels[user1]

movies_user2 <- gsub('m','',movies_user1)
movies_user2
```
```{r}
movie_list = movies_user2
Drama_rated_movie <- movies %>% 
  filter(MovieID %in% movie_list ) %>%
  mutate(Image = paste0('<img src="', 
                        small_image_url, 
                        MovieID, 
                        '.jpg?raw=true"></img>')) %>%
  select('Image', 'Title') %>%
  datatable(class = "nowrap hover row-border", 
            escape = FALSE, 
            options = list(dom = 't',
                          scrollX = TRUE, autoWidth = TRUE))
```

```{r}
(Drama_rated_movie)
```


Output Top 10 high rated Drama movie


```{r}
movie_name = "Action"
print(as.name(movie_name))
Drama_rated_movie <- ratings %>% 
  left_join(data.frame(MovieID = movies$MovieID, genre_df), 
            by = "MovieID") %>%
  filter(get(movie_name) == 1) %>%
  group_by(MovieID) %>% 
  summarize(ratings_per_movie = n(), 
            ave_ratings = round(mean(Rating), dig=3)) %>%
  inner_join(movies, by = 'MovieID') %>%
  filter(ratings_per_movie > 1000) %>%
  top_n(10, ave_ratings) %>%
  mutate(Image = paste0('<img src="', 
                        small_image_url, 
                        MovieID, 
                        '.jpg?raw=true"></img>')) %>%
  select('Image', 'Title', 'ave_ratings') %>%
  arrange(desc(-ave_ratings)) %>%
  datatable(class = "nowrap hover row-border", 
            escape = FALSE, 
            options = list(dom = 't',
                          scrollX = TRUE, autoWidth = TRUE))
  
Drama_rated_movie
```
`

System II: Collaborative recommendation system
```{r}
library(recommenderlab)
myurl = "https://liangfgithub.github.io/MovieData/"
ratings = read.csv(paste0(myurl, 'ratings.dat?raw=true'), 
                   sep = ':',
                   colClasses = c('integer', 'NULL'), 
                   header = FALSE)
colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')
i = paste0('u', ratings$UserID)
j = paste0('m', ratings$MovieID)
x = ratings$Rating
tmp = data.frame(i, j, x, stringsAsFactors = T)
Rmat = sparseMatrix(as.integer(tmp$i), as.integer(tmp$j), x = tmp$x)
rownames(Rmat) = levels(tmp$i)
colnames(Rmat) = levels(tmp$j)
Rmat = new('realRatingMatrix', data = Rmat)

train = Rmat[1:500, ]
test = Rmat[501, ]
```
```{r}

```
UBCF Implementation

```{r}
# Normalize
train = Rmat[1:500, ]
data = as(train, "matrix")
user.means = rowMeans(data, na.rm = TRUE)
data = data - user.means

test = Rmat[501, ]
newdata = as(test, "matrix")
newuser.mean = mean(newdata, na.rm = TRUE)
newdata = newdata - newuser.mean
dim(data)
```
Compute similarity

```{r}
sim = rep(0, dim(data)[1])
for (i in 1:length(sim)){
  temp.y = as.vector(newdata)
  ind.y = which(!is.na(temp.y))
  temp.x = data[i,]
  ind.x = which(!is.na(temp.x))
  ind = intersect(ind.x, ind.y)
  if (length(ind) >0 ){
    temp.x = temp.x[ind]
    temp.y = temp.y[ind]
    sim[i] = sum(temp.x * temp.y) / sqrt(sum(temp.x^2)*sum(temp.y^2))

  }
}
sim = (1+sim)/2

sort_data <- sort(sim,decreasing=TRUE, index.return = TRUE)

top20= head(sort_data$x,n = 20)
top20_index = head(sort_data$ix,n = 20)


```

```{r}
sim1 = proxy::simil(data, newdata, method = "cosine")
sim1 = (1+sim1)/2
sum((sim-sim1)^2)


```

```{r}
train_top20 <- as(data[top20_index,],"matrix")

dim(train_top20)

```



Compute the weighted average of the K users
```{r}

mypred <- matrix(NA, nrow = 1, ncol =dim(train_top20)[2] )


for (i in 1:dim(train_top20)[2]){#dim(train_top20)[2]
  
  tmp.y = as.vector(train_top20[,i])
  ind.y = which(!is.na(tmp.y))
  ind.x = which(!is.na(top20))
  ind = intersect(ind.x, ind.y)
  if(length(ind)>0){
      tmp.newy <- tmp.y[ind]
      tmp.x <- top20[ind]
      mypred[i] = sum(tmp.newy*tmp.x)/(sum(tmp.x)) + newuser.mean

  }   

}
test_matrix = as(test,"matrix")
mypred[which(is.infinite(mypred))] = NA
mypred[which(!is.na(test_matrix))] =NA

print(sum(is.na(mypred)))

```

```{r}
recommender.UBCF <- Recommender(train, method = "UBCF",
                                parameter = list(normalize = 'center', 
                                                 method = 'Cosine', 
                                                 nn = 20))

p.UBCF <- predict(recommender.UBCF, test, type="ratings")
p.UBCF <- as.numeric(as(p.UBCF, "matrix"))
dim(p.UBCF)
print("should be zero")
sum(is.na(p.UBCF) != is.na(mypred)) ### should be zero
print("should be less than 1e-06")
max(abs(p.UBCF - mypred), na.rm = TRUE)  ### should be less than 1e-06
```


IBCF Implementation
Implementing Item based recommender systems, like user based collaborative filtering, requires two steps:

Calculating Item similarities
Predicting the targeted item rating for the targeted User.
Step1: Calculating Item Similarity: we calculate the similarity between co-rated items. We use cosine similarity compute the similarity between items.

The output for step is similarity matrix between Items.

```{r}
# Compute similarity (m x m)
# let diagonal = 0
item.sim = matrix(0, nrow = dim(data)[2], ncol = dim(data)[2])


```

```{r}
item.sim = proxy::simil(t(data), method = "cosine")
item.sim  = (1+item.sim )/2

```


```{r}

# Create a matrix that picks 30 nearest neighbors for each row
item.sim <- as(item.sim,"matrix")
item.sim.top30 = item.sim

for (i in 1:dim(item.sim)[1]){#dim(item.sim)[1]
 neighbor_ids = tail(order(item.sim[i,], decreasing = FALSE,na.last=FALSE), 30)
 item.sim.top30[i,-neighbor_ids]=NA

}

```
```{r}

mypred_item <- matrix(NA, nrow = 1, ncol =dim(item.sim.top30)[2] )
test_matrix = as(test,"matrix")

for (i in 1:dim(train_top20)[2]){#dim(train_top20)[2]
  
  tmp.y = as.vector(item.sim.top30[i,])
  ind.y = which(!is.na(tmp.y))
  ind.x = which(!is.na(test_matrix))
  ind = intersect(ind.x, ind.y)
  if(length(ind)>0){
      tmp.newy <- tmp.y[ind]
      tmp.x <- test_matrix[ind]
      mypred_item[i] = sum(tmp.newy*tmp.x)/(sum(tmp.newy))# + newuser.mean
  }   

}
test_matrix = as(test,"matrix")
mypred_item[which(is.infinite(mypred))] = NA
mypred_item[which(!is.na(test_matrix))] =NA

print(sum(is.na(mypred_item)))
```

```{r}
recommender.IBCF <- Recommender(train, method = "IBCF",
                                parameter = list(normalize = 'center', 
                                                 method = 'Cosine', 
                                                 k = 30))

p.IBCF <- predict(recommender.IBCF, test, type="ratings")
p.IBCF <- as.numeric(as(p.IBCF, "matrix"))
sum(is.na(p.IBCF))

## first output: should be less than 10
print("first output: should be less than 10")
sum(is.na(p.IBCF) != is.na(mypred_item))  

## second output: should be less than 10%
mydiff = abs(p.IBCF - mypred_item)
print("second output: should be less than 10%")
sum(mydiff[!is.na(mydiff)] > 1e-6) / sum(!is.na(mydiff)) 
```
