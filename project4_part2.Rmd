---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
```{r}
library(recommenderlab)
myurl = "https://liangfgithub.github.io/MovieData/"
ratings = read.csv(paste0(myurl, 'ratings.dat?raw=true'), 
                   sep = ':',
                   colClasses = c('integer', 'NULL'), 
                   header = FALSE)
colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')
i = paste0('u', ratings$UserID)
j = paste0('m', ratings$MovieID)
x = ratings$Rating
tmp = data.frame(i, j, x, stringsAsFactors = T)
Rmat = sparseMatrix(as.integer(tmp$i), as.integer(tmp$j), x = tmp$x)
rownames(Rmat) = levels(tmp$i)
colnames(Rmat) = levels(tmp$j)
print(Rmat[501,])
Rmat = new('realRatingMatrix', data = Rmat)

train = Rmat[1:500, ]
test = Rmat[501, ]
print(dim(test))
```
```{r}
print(test)
```


```{r}
# Normalize
train = Rmat[1:500, ]
data = as(train, "matrix")
user.means = rowMeans(data, na.rm = TRUE)
data = data - user.means

test = Rmat[501, ]
newdata = as(test, "matrix")
newuser.mean = mean(newdata, na.rm = TRUE)
newdata = newdata - newuser.mean
dim(data)
```
Compute similarity

```{r}
sim = rep(0, dim(data)[1])
for (i in 1:length(sim)){
  temp.y = as.vector(newdata)
  ind.y = which(!is.na(temp.y))
  temp.x = data[i,]
  ind.x = which(!is.na(temp.x))
  ind = intersect(ind.x, ind.y)
  if (length(ind) >0 ){
    temp.x = temp.x[ind]
    temp.y = temp.y[ind]
    sim[i] = sum(temp.x * temp.y) / sqrt(sum(temp.x^2)*sum(temp.y^2))

  }
}
sim = (1+sim)/2

sort_data <- sort(sim,decreasing=TRUE, index.return = TRUE)

top20= head(sort_data$x,n = 20)
top20_index = head(sort_data$ix,n = 20)


```

```{r}
sim1 = proxy::simil(data, newdata, method = "cosine")
sim1 = (1+sim1)/2
sum((sim-sim1)^2)


```

```{r}
train_top20 <- as(data[top20_index,],"matrix")

dim(train_top20)

```



Compute the weighted average of the K users
```{r}

mypred <- matrix(NA, nrow = 1, ncol =dim(train_top20)[2] )


for (i in 1:dim(train_top20)[2]){#dim(train_top20)[2]
  
  tmp.y = as.vector(train_top20[,i])
  ind.y = which(!is.na(tmp.y))
  ind.x = which(!is.na(top20))
  ind = intersect(ind.x, ind.y)
  if(length(ind)>0){
      tmp.newy <- tmp.y[ind]
      tmp.x <- top20[ind]
      mypred[i] = sum(tmp.newy*tmp.x)/(sum(tmp.x)) + newuser.mean

  }   

}
test_matrix = as(test,"matrix")
mypred[which(is.infinite(mypred))] = NA
mypred[which(!is.na(test_matrix))] =NA

print(sum(is.na(mypred)))

```
```{r}
print(dim(train))
print(train[1])
print(test)
```

```{r}
recommender.UBCF <- Recommender(train, method = "UBCF",
                                parameter = list(normalize = 'center', 
                                                 method = 'Cosine', 
                                                 nn = 20))

p.UBCF <- predict(recommender.UBCF, test, type="ratings")
p.UBCF <- as.numeric(as(p.UBCF, "matrix"))
dim(p.UBCF)
print("should be zero")
sum(is.na(p.UBCF) != is.na(mypred)) ### should be zero
print("should be less than 1e-06")
max(abs(p.UBCF - mypred), na.rm = TRUE)  ### should be less than 1e-06
```


IBCF Implementation
Implementing Item based recommender systems, like user based collaborative filtering, requires two steps:

Calculating Item similarities
Predicting the targeted item rating for the targeted User.
Step1: Calculating Item Similarity: we calculate the similarity between co-rated items. We use cosine similarity compute the similarity between items.

The output for step is similarity matrix between Items.

```{r}
# Compute similarity (m x m)
# let diagonal = 0
item.sim = matrix(0, nrow = dim(data)[2], ncol = dim(data)[2])


```

```{r}
item.sim = proxy::simil(t(data), method = "cosine")
item.sim  = (1+item.sim )/2

```


```{r}

# Create a matrix that picks 30 nearest neighbors for each row
item.sim.top30 = item.sim

for (i in 1:dim(item.sim)[1]){#dim(item.sim)[1]
 neighbor_ids = tail(order(item.sim[i,], decreasing = FALSE,na.last=FALSE), 30)
 item.sim.top30[i,-neighbor_ids]=NA

}

```
```{r}

mypred_item <- matrix(NA, nrow = 1, ncol =dim(item.sim.top30)[2] )
test_matrix = as(test,"matrix")

for (i in 1:dim(train_top20)[2]){#dim(train_top20)[2]
  
  tmp.y = as.vector(item.sim.top30[i,])
  ind.y = which(!is.na(tmp.y))
  ind.x = which(!is.na(test_matrix))
  ind = intersect(ind.x, ind.y)
  if(length(ind)>0){
      tmp.newy <- tmp.y[ind]
      tmp.x <- test_matrix[ind]
      mypred_item[i] = sum(tmp.newy*tmp.x)/(sum(tmp.newy))# + newuser.mean
  }   

}
test_matrix = as(test,"matrix")
mypred_item[which(is.infinite(mypred))] = NA
mypred_item[which(!is.na(test_matrix))] =NA

print(sum(is.na(mypred_item)))
```

```{r}
recommender.IBCF <- Recommender(train, method = "IBCF",
                                parameter = list(normalize = 'center', 
                                                 method = 'Cosine', 
                                                 k = 30))

p.IBCF <- predict(recommender.IBCF, test, type="ratings")
p.IBCF <- as.numeric(as(p.IBCF, "matrix"))
sum(is.na(p.IBCF))

## first output: should be less than 10
print("first output: should be less than 10")
sum(is.na(p.IBCF) != is.na(mypred_item))  

## second output: should be less than 10%
mydiff = abs(p.IBCF - mypred_item)
print("second output: should be less than 10%")
sum(mydiff[!is.na(mydiff)] > 1e-6) / sum(!is.na(mydiff)) 
```

```{r}
dim(Rmat)
test_item <- matrix(0, nrow = 1, ncol =ncol(Rmat) )
dim(test_item)
colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')
i = paste0('u', ratings$UserID)
j = paste0('m', ratings$MovieID)
x = ratings$Rating
tmp = data.frame(i, j, x, stringsAsFactors = T)
Rmat = sparseMatrix(as.integer(tmp$i), as.integer(tmp$j), x = tmp$x)
rownames(Rmat) = levels(tmp$i)
colnames(Rmat) = levels(tmp$j)

NewMatrix <- rbind(Rmat, test_item)
dim(NewMatrix)
print(NewMatrix[6041,])
```

